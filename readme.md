# Язык Программирования


## Немного о самом языке

Язык по своей структуре похож на язык программирования C, но ключевые слова в нем немного видоизменены в угоду автора.

Ниже приведены основные конструкции синтаксиса языка:
- объявление функции:
    ``` 
    ситуация <название функции> (параметры функции) {...} 
    ```
- возврат из функции:
    ``` 
    отзови <возвращаемое значение>;
    ```
- вызов функции:
    ``` 
    позови-ка <название функции> (аргументы функции);
    ```
- объявление переменной:
    ``` 
    ну-ка <имя переменной>; 
    ```
- условное выражение `проверим` эквивалентен `if` в Си;

- бинарные и унарные операторы как в Си.

Например, программа, наивно вычисляющая факториал числа, будет выглядеть так:
```
ситуация factorial(x)
{
    ну-ка res = x;

    проверим (x < 0)
    {
        отзови 0;
    }
    проверим (x == 1 || x == 0)
    {
        отзови 1;
    }
    проверим (x > 1)
    {
        res = res * позови factorial (x - 1);
    }

    отзови res;
}

ситуация main ()
{
    ну-ка a2 = позови read();

    a2 = позови factorial (a2);
    позови print (a2);

    отзови 0;
}
```

## Реализация

Обработка программы проходит в несколько этапов: 
1. обработка лексем и составление синтаксического дерева методом рекурсивного спуска (`frontend`)
2. составление [ассемблерного](https://github.com/MishenkovDaniil/assembler-cpu) кода программы и его запуск в [собственном процессоре](https://github.com/MishenkovDaniil/assembler-cpu) (`backend`).
3. Вывод результата в консоль.


## Грамматика языка

Грамматика языка используется при построении синтаксического дерева и в рекурсивном спуске.

```
Grammar  ::= Defs
    Defs     ::= (Nvar | Nfun) Defs*

    Nvar     ::= Name Expr
    Nfun     ::= Name Par* Block
    Par      ::= Name

    Block    ::= Seq
    Seq      ::= (Block | Nvar | Ass | If | While | Call | Ret) Seq*
    Ass      ::= Var Expr
    If       ::= "if"     '(' Expr ')'
    While    ::= "while"  '(' Expr ')'
    Call     ::= Name Arg
    Arg      ::= Const Arg*
    Ret      ::= Expr

    Op       ::= '+' | '-' | '*' | '/' | '^'
    Expr     ::= F (['>' | '<'] T)*
    F        ::= T (['+' | '-'] T)*
    T        ::= Deg (['*' | '/'] Deg)*
    Deg      ::= Primary ('^' Primary)*
    Primary  ::= '('Expr')' | Var | Const | Call
    Name     ::= ['a'-'z','0'-'9','_']+
    Var      ::= ['a'-'z', '_'] ['a'-'z','0'-'9','_']+
    Const    ::= ['0'-'9']+
```

*Замечание: `Name` отличается от `Var` отсутствием объявления.*